/*******************************************************************
Copyright(c) 2018, Yu Xiaoxian
All rights reserved.
Distributed under the BSD license.
(See accompanying file LICENSE.txt at
https://github.com/Yu-Xiaoxian/CodingInterview/blob/master/LICENSE.txt)
*******************************************************************/

//已知前序遍历和中序遍历的结果，请重建二叉树

/*
思路一：
前序遍历第一个对象一定是根节点，中序遍历第一个对象一定是左叶节点。
1. 首先生成一个节点，根据前序遍历依次将节点加到二叉树左侧，直到等于中序遍历的值；
维护一个curr指针，指向当前节点。
2. 判断中序遍历的值是否等于当前节点的父节点，如果是，将curr指针移到其父节点，如果不是，将中序遍历的当前对象加到curr指向节点的右节点，直到curr指向根节点；
重复1,2两步

思路二：递归
中序遍历中，根节点之前都是其左子树节点的值，根节点之后都是其右子树的值。
将问题划分为两个等价的子问题，遍历中序遍历的结果，找到根节点的位置，从而划分为两个子序列。
*/



int main() {
	
}